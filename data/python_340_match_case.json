[
    {
        "question": "Как можно разделить введенную пользователем строку на отдельные слова?",
        "answer": "Для разделения строки на отдельные слова можно использовать метод split(). Например:\n\ncommand = input('What are you doing next? ')\nwords = command.split()\nprint(words)"
    },
    {
        "question": "Как можно проверить, что пользователь ввел ровно два слова?",
        "answer": "Для проверки, что пользователь ввел ровно два слова, можно использовать условное выражение с оператором len(). Например:\n\ncommand = input('What are you doing next? ')\nwords = command.split()\nif len(words) == 2:\n    print('Два слова введены')\nelse:\n    print('Нужно ввести ровно два слова')"
    },
    {
        "question": "Как можно использовать оператор match для проверки структуры и привязки значений?",
        "answer": "Оператор match позволяет проверить структуру и привязать значения к переменным. Например:\n\ncommand = input('What are you doing next? ')\n\nmatch command.split():\n    case [action, obj]:\n        print('Action:', action)\n        print('Object:', obj)\n    case _:\n        print('Invalid input')\n\nВ этом примере, если пользователь ввел два слова, то значения будут привязаны к переменным action и obj. Если пользователь ввел другое количество слов, будет выполнен блок case _."
    },
    {
        "question": "Как можно использовать оператор match для проверки нескольких паттернов?",
        "answer": "Оператор match может проверять несколько паттернов. Например:\n\nmatch command.split():\n    case [action]:\n        print('Одно слово введено')\n    case [action, obj]:\n        print('Два слова введены')\n\nВ этом примере, если пользователь ввел одно слово, будет выполнен блок case [action]. Если пользователь ввел два слова, будет выполнен блок case [action, obj]."
    },
    {
        "question": "Как можно использовать литеральные значения в паттернах оператора match?",
        "answer": "Литеральные значения могут быть использованы в паттернах оператора match. Например:\n\nmatch command.split():\n    case ['quit']:\n        print('Goodbye!')\n        quit_game()\n    case ['look']:\n        current_room.describe()\n    case ['get', obj]:\n        character.get(obj, current_room)\n    case ['go', direction]:\n        current_room = current_room.neighbor(direction)\n    # Другие команды\n\nВ этом примере, если пользователь ввел 'quit', будет выполнен блок case ['quit']. Если пользователь ввел 'look', будет выполнен блок case ['look']. И так далее."
    },
    {
        "question": "Как можно сопоставить несколько значений в операторе match?",
        "answer": "Для сопоставления нескольких значений в операторе match можно использовать синтаксис с несколькими паттернами. Например:\n\nmatch command.split():\n    case ['drop', *objects]:\n        for obj in objects:\n            drop_item(obj)\n\nВ этом примере, если пользователь ввел команду 'drop key sword', будет выполнен блок case ['drop', *objects], где objects будет содержать список ['key', 'sword']. Затем каждый объект из списка будет передан в функцию drop_item()."
    },
    {
        "question": "Как можно использовать подстановочный символ (wildcard) в операторе match?",
        "answer": "Подстановочный символ (wildcard) в операторе match используется для сопоставления любого объекта, но без привязки к переменной. Например:\n\nmatch command.split():\n    case [*ignored_words]:\n        print('Команда не распознана')\n\nВ этом примере, если ни один из предыдущих паттернов не совпал с введенной командой, будет выполнен блок case [*ignored_words], который просто выведет сообщение 'Команда не распознана'."
    },
    {
        "question": "Как можно составлять паттерны в операторе match?",
        "answer": "В операторе match можно составлять паттерны из различных элементов. Например:\n\nmatch subject:\n    case [action, (left, right), _, *rest]:\n        ... # выполнение кода\n\nВ этом примере, паттерн состоит из следующих элементов:\n- capture pattern (action) - захватывает значение первого элемента списка\n- literal pattern ((left, right)) - сопоставляет точное значение кортежа\n- wildcard pattern (_) - сопоставляет любой объект без привязки\n- starred pattern (*rest) - захватывает оставшиеся элементы списка\n\nТакой паттерн будет совпадать с объектами, которые являются списком из как минимум трех элементов, где первый элемент равен 'action', второй элемент - кортеж (left, right), третий элемент - любой объект, а остальные элементы захватываются в список rest."
    },
    {
        "question": "Какие преимущества и недостатки имеет использование символа | в шаблонах?",
        "answer": "Использование символа | в шаблонах позволяет объединять несколько шаблонов в альтернативы. Это полезно, когда требуется, чтобы несколько шаблонов приводили к одному и тому же результату. Например, можно объединить шаблоны ['north'] и ['go', 'north'] в одну альтернативу, чтобы обработать команды 'north' и 'go north' одинаковым образом.\n\nОднако, при использовании символа | все альтернативы должны привязывать одни и те же переменные. Нельзя использовать шаблоны, которые привязывают разные переменные, так как это может привести к неоднозначности. Например, шаблон [1, x] | [2, y] не допускается, так как неясно, какая переменная будет привязана после успешного сопоставления. Шаблон [1, x] | [2, x] допустим и всегда привяжет переменную x в случае успешного сопоставления."
    },
    {
        "question": "Что такое захват подшаблонов и как его использовать в шаблонах?",
        "answer": "Захват подшаблонов - это возможность привязать значение, соответствующее определенному шаблону, к имени переменной. В Python это можно сделать с помощью as-шаблона.\n\nНапример, в коде match command.split():\n    case ['go', ('north' | 'south' | 'east' | 'west') as direction]:\n        current_room = current_room.neighbor(direction)\n\nШаблон ('north' | 'south' | 'east' | 'west') привязывает значение, соответствующее одному из направлений, к переменной direction. Это позволяет использовать привязанное значение в дальнейшем коде, например, для перемещения игрока в соответствующую комнату."
    },
    {
        "question": "Как добавить условия к шаблонам в Python?",
        "answer": "В Python можно добавить условия к шаблонам с помощью гварда (guard). Гвард представляет собой ключевое слово if, за которым следует логическое выражение.\n\nНапример, в коде match command.split():\n    case ['go', direction] if direction in current_room.exits:\n        current_room = current_room.neighbor(direction)\n    case ['go', _]:\n        print('Извините, вы не можете пойти в этом направлении')\n\nГвард не является частью шаблона, он является частью ветви case. Он проверяется только в случае успешного сопоставления шаблона и после привязки переменных. Если условие гварда истинно, выполняется тело ветви case. Если условие гварда ложно, match-выражение переходит к следующей ветви case, как если бы шаблон не сопоставился (с возможным побочным эффектом привязки некоторых переменных)."
    },
    {
        "question": "Что такое or pattern в операторе match?",
        "answer": "Or pattern в операторе match позволяет иметь несколько паттернов, приводящих к одному и тому же результату. Например, вы можете захотеть, чтобы команды 'north' и 'go north' были эквивалентными. Для этого можно использовать следующий паттерн:\n\nmatch command.split():\n    case ['north'] | ['go', 'north']:\n        ... # Код для выполнения действия 'north'\n\nЭтот паттерн будет совпадать с обоими командами и выполнит соответствующий код для действия 'north'."
    },
    {
        "question": "Как работает or pattern в операторе match?",
        "answer": "Or pattern в операторе match проверяет паттерны слева направо. Если один из паттернов совпадает с введенной командой, то выполняется соответствующий блок кода. Паттерны проверяются по порядку, и первый совпавший паттерн будет использован. Если паттерн совпадает, но условие в блоке case является ложным, то код внутри блока case не будет выполнен. Это позволяет выбирать различные паттерны для одного и того же результата в операторе match."
    },
    {
        "question": "Какие примеры объектов могут быть созданы в результате использования оператора match?",
        "answer": "В результате использования оператора match могут быть созданы различные объекты в зависимости от действий пользователя. Например:\n\n- Объект KeyPress создается, когда пользователь нажимает клавишу. Он имеет атрибут key_name с именем нажатой клавиши и другие атрибуты, относящиеся к модификаторам.\n- Объект Click создается, когда пользователь кликает мышью. Он может иметь атрибуты, связанные с координатами клика и другими свойствами.\n\nТаким образом, оператор match позволяет создавать объекты с различными типами и атрибутами в зависимости от действий пользователя."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с константами и перечислениями?",
        "answer": "Оператор match позволяет сопоставлять с константами и перечислениями. Например, если у вас есть перечисление Button, вы можете сопоставить левый клик следующим образом:\n\nmatch event.get():\n    case Click((x, y), button=Button.LEFT):\n        handle_click_at(x, y)\n    case Click():\n        pass  # игнорировать другие клики\n\nЭто сопоставление будет работать с любыми значениями перечисления Button, такими как Button.LEFT, Button.RIGHT и т. д."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с маппингами (словарями)?",
        "answer": "Оператор match позволяет сопоставлять с маппингами (словарями) на основе их ключей. Например, если у вас есть список словарей actions, вы можете сопоставить каждый словарь с помощью оператора match следующим образом:\n\nfor action in actions:\n    match action:\n        case {'text': message, 'color': c}:\n            ui.set_text_color(c)\n            ui.display(message)\n        case {'sleep': duration}:\n            ui.wait(duration)\n        case {'sound': url, 'format': 'ogg'}:\n            ui.play(url)\n        case {'sound': _, 'format': _}:\n            warning('Unsupported audio format')\n\nВ этом примере ключи в словаре должны быть литералами, а значения могут быть любыми паттернами. Вы также можете использовать **rest внутри маппинга для захвата дополнительных ключей."
    },
    {
        "question": "Как можно сопоставлять константы и перечисления в операторе match?",
        "answer": "В операторе match можно сопоставлять константы и перечисления, используя соответствующие значения. Например, если у вас есть перечисление Button и вы хотите сопоставить левый клик, вы можете написать следующий код:\n\nmatch event.get():\n    case Click((x, y), button=Button.LEFT):\n        handle_click_at(x, y)\n    case Click():\n        pass  # игнорировать другие кнопки\n\nВ этом примере, если событие является левым кликом, будет выполнен блок кода в первом case. Если событие не является левым кликом, будет выполнен блок кода во втором case, который игнорирует другие кнопки."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с константами и перечислениями?",
        "answer": "Оператор match позволяет сопоставлять с константами и перечислениями. Например, если у вас есть перечисление Button, вы можете сопоставить левый клик следующим образом:\n\nmatch event.get():\n    case Click((x, y), button=Button.LEFT):\n        handle_click_at(x, y)\n    case Click():\n        pass  # игнорировать другие клики\n\nЭто сопоставление будет работать с любыми значениями перечисления Button, такими как Button.LEFT, Button.RIGHT и т. д."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с маппингами (словарями)?",
        "answer": "Оператор match позволяет сопоставлять с маппингами (словарями) на основе их ключей. Например, если у вас есть список словарей actions, вы можете сопоставить каждый словарь с помощью оператора match следующим образом:\n\nfor action in actions:\n    match action:\n        case {'text': message, 'color': c}:\n            ui.set_text_color(c)\n            ui.display(message)\n        case {'sleep': duration}:\n            ui.wait(duration)\n        case {'sound': url, 'format': 'ogg'}:\n            ui.play(url)\n        case {'sound': _, 'format': _}:\n            warning('Unsupported audio format')\n\nВ этом примере ключи в словаре должны быть литералами, а значения могут быть любыми паттернами. Вы также можете использовать **rest внутри маппинга для захвата дополнительных ключей."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с классами и их атрибутами?",
        "answer": "Оператор match позволяет сопоставлять с классами и их атрибутами. Например, если у вас есть класс Point с атрибутами x и y, вы можете сопоставить объекты этого класса следующим образом:\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n\ndef where_is(point):\n    match point:\n        case Point(x=0, y=0):\n            print('Origin')\n        case Point(x=0, y=y):\n            print(f'Y={y}')\n        case Point(x=x, y=0):\n            print(f'X={x}')\n        case Point():\n            print('Somewhere else')\n        case _:\n            print('Not a point')\n\nВ этом примере мы сопоставляем объекты класса Point с различными шаблонами. Мы можем использовать атрибуты класса и значения для сопоставления и выполнения соответствующих действий."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с константами и перечислениями?",
        "answer": "Оператор match позволяет сопоставлять с константами и перечислениями. Например, если у вас есть перечисление Button, вы можете сопоставить левый клик следующим образом:\n\nmatch event.get():\n    case Click((x, y), button=Button.LEFT):\n        handle_click_at(x, y)\n    case Click():\n        pass  # игнорировать другие клики\n\nЭто сопоставление будет работать с любыми значениями перечисления Button, такими как Button.LEFT, Button.RIGHT и т. д."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с маппингами (словарями)?",
        "answer": "Оператор match позволяет сопоставлять с маппингами (словарями) на основе их ключей. Например, если у вас есть список словарей actions, вы можете сопоставить каждый словарь с помощью оператора match следующим образом:\n\nfor action in actions:\n    match action:\n        case {'text': message, 'color': c}:\n            ui.set_text_color(c)\n            ui.display(message)\n        case {'sleep': duration}:\n            ui.wait(duration)\n        case {'sound': url, 'format': 'ogg'}:\n            ui.play(url)\n        case {'sound': _, 'format': _}:\n            warning('Unsupported audio format')\n\nВ этом примере ключи в словаре должны быть литералами, а значения могут быть любыми паттернами. Вы также можете использовать **rest внутри маппинга для захвата дополнительных ключей."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с классами и их атрибутами?",
        "answer": "Оператор match позволяет сопоставлять с классами и их атрибутами. Например, если у вас есть класс Point с атрибутами x и y, вы можете сопоставить объекты этого класса следующим образом:\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n\ndef where_is(point):\n    match point:\n        case Point(x=0, y=0):\n            print('Origin')\n        case Point(x=0, y=y):\n            print(f'Y={y}')\n        case Point(x=x, y=0):\n            print(f'X={x}')\n        case Point():\n            print('Somewhere else')\n        case _:\n            print('Not a point')\n\nВ этом примере мы сопоставляем объекты класса Point с различными шаблонами. Мы можем использовать атрибуты класса и значения для сопоставления и выполнения соответствующих действий."
    },
    {
        "question": "Как можно использовать оператор match для сопоставления с перечислениями?",
        "answer": "Оператор match позволяет сопоставлять с перечислениями. Например, если у вас есть перечисление Color, вы можете сопоставить каждое значение перечисления следующим образом:\n\nfrom enum import Enum\nclass Color(Enum):\n    RED = 0\n    GREEN = 1\n    BLUE = 2\n\nmatch color:\n    case Color.RED:\n        print('I see red!')\n    case Color.GREEN:\n        print('Grass is green')\n    case Color.BLUE:\n        print('I'm feeling the blues :(')\n\nВ этом примере мы сопоставляем значение переменной color с каждым значением перечисления Color и выполняем соответствующие действия."
    }
]
